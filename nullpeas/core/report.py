from __future__ import annotations
from pathlib import Path
from typing import List, Dict, Any, Optional
import datetime
import json


class Report:
    """
    Nullpeas unified reporting engine.

    Responsibilities:
    - Accept traditional module sections (text reporting).
    - Accept structured offensive primitives.
    - Accept structured attack chains from the chaining engine.
    - Render clean Markdown for operators / defenders.
    - Export structured JSON for tooling / automation.

    Notes:
    - Backwards compatible with legacy add_section().
    - Does not execute exploits or modify system state.
    """

    def __init__(
        self,
        title: str = "Nullpeas Local Privilege Escalation Assessment",
        output_dir: str = "cache",
    ):
        self.title = title
        self.output_dir = Path(output_dir)

        # Human-readable document sections
        self.sections: List[Dict[str, Any]] = []

        # Structured intelligence for chaining + machine usage
        self.primitives: List[Dict[str, Any]] = []
        self.attack_chains: List[Dict[str, Any]] = []

    # ----------------------------------------------------------------------
    # Public API – TEXT REPORTING
    # ----------------------------------------------------------------------

    def add_section(self, heading: str, body_lines: List[str]):
        self.sections.append(
            {
                "heading": heading,
                "body_lines": body_lines or [],
            }
        )

    def add_finding(
        self,
        heading: str,
        summary: str,
        details: Optional[List[str]] = None,
    ):
        lines = [summary]
        if details:
            lines.append("")
            lines.extend(details)
        self.add_section(heading, lines)

    # ----------------------------------------------------------------------
    # Public API – OFFENSIVE PRIMITIVES
    # ----------------------------------------------------------------------

    def add_primitive(self, primitive: Any):
        """
        Accepts a Primitive dataclass OR dict.

        The chaining engine primarily works off state, but the report
        also presents primitives for human review.
        """
        if hasattr(primitive, "__dict__"):
            primitive = primitive.__dict__
        self.primitives.append(primitive)

    def add_primitives(self, prims: List[Any]):
        for p in prims:
            self.add_primitive(p)

    # ----------------------------------------------------------------------
    # Public API – ATTACK CHAINS
    # ----------------------------------------------------------------------

    def add_attack_chain(self, chain: Dict[str, Any]):
        """
        Chain schema is generated by chaining_engine.
        Report is responsible for clear presentation only.
        """
        self.attack_chains.append(chain)

    def add_attack_chains(self, chains: List[Dict[str, Any]]):
        for c in chains:
            self.add_attack_chain(c)

    # ----------------------------------------------------------------------
    # MARKDOWN RENDERING
    # ----------------------------------------------------------------------

    def _render_header(self) -> List[str]:
        ts = datetime.datetime.utcnow().isoformat(timespec="seconds") + "Z"

        return [
            f"# {self.title}",
            "",
            f"_Generated: {ts}_",
            "",
            "---",
            "",
        ]

    def _render_sections(self) -> List[str]:
        lines: List[str] = []
        for section in self.sections:
            lines.append(f"## {section['heading']}")
            lines.append("")
            lines.extend(section["body_lines"])
            lines.append("")
        return lines

    def _render_attack_chains(self) -> List[str]:
        if not self.attack_chains:
            return []

        lines: List[str] = []
        lines.append("## Offensive Attack Chains")
        lines.append("")
        lines.append(
            "This section documents plausible local privilege escalation paths derived from the discovered primitives."
        )
        lines.append(
            "Nullpeas does not execute any exploits; chains are modelled for analysis and operator decision-making only."
        )
        lines.append("")

        for idx, chain in enumerate(self.attack_chains, start=1):
            title = chain.get("title") or chain.get("goal") or "Unnamed chain"
            lines.append(f"### Chain {idx}: {title}")
            lines.append("")

            if desc := chain.get("description"):
                lines.append(desc)
                lines.append("")

            if primitives := chain.get("primitives", []):
                lines.append("**Primitives utilised:**")
                for p in primitives:
                    lines.append(f"- `{p}`")
                lines.append("")

            if path := chain.get("chain_path", []):
                lines.append("**Chain path:**")
                for step in path:
                    lines.append(f"- {step}")
                lines.append("")

            if impact := chain.get("impact"):
                lines.append("**Impact:**")
                lines.append(f"- {impact}")
                lines.append("")

            if guidance := chain.get("guidance", []):
                lines.append("**Operator notes:**")
                for g in guidance:
                    lines.append(f"- {g}")
                lines.append("")

            confidence = chain.get("confidence")
            if confidence:
                score = confidence.get("score")
                reason = confidence.get("reason")
                lines.append("**Chain confidence:**")
                if score is not None:
                    lines.append(f"- {score}/10")
                if reason:
                    lines.append(f"- {reason}")
                lines.append("")

            lines.append("---")
            lines.append("")

        return lines

    def _render_primitives(self) -> List[str]:
        if not self.primitives:
            return []

        lines: List[str] = []
        lines.append("## Offensive Primitives")
        lines.append("")
        lines.append(
            "These are individual local privilege escalation or control opportunities identified on the host."
        )
        lines.append(
            "They are represented in a structured form for analysis and chaining, and are not executed by Nullpeas."
        )
        lines.append("")

        for p in self.primitives:
            primitive_id = p.get("id", "primitive")
            primitive_type = p.get("type", "unknown_type")

            lines.append(f"### {primitive_id} ({primitive_type})")
            lines.append("")

            lines.append(f"**Surface:** `{p.get('surface')}`")
            lines.append(f"**Run as:** `{p.get('run_as')}`")
            lines.append(f"**Exploitability:** `{p.get('exploitability')}`")
            lines.append(f"**Stability:** `{p.get('stability')}`")
            lines.append(f"**Noise:** `{p.get('noise')}`")

            conf = p.get("confidence", {}) or {}
            score = conf.get("score", "?")
            reason = conf.get("reason")
            lines.append(f"**Confidence:** {score}/10")
            if reason:
                lines.append(f"- {reason}")

            val = p.get("offensive_value", {}) or {}
            if val:
                lines.append("")
                lines.append("**Offensive value:**")
                classification = val.get("classification")
                why = val.get("why")
                if classification:
                    lines.append(f"- Classification: {classification}")
                if why:
                    lines.append(f"- Rationale: {why}")

            ctx = p.get("context") or {}
            if ctx:
                lines.append("")
                lines.append("**Context:**")
                for k, v in ctx.items():
                    lines.append(f"- {k}: {v}")

            lines.append("")
            lines.append("---")
            lines.append("")

        return lines

    # ----------------------------------------------------------------------
    # JSON EXPORT
    # ----------------------------------------------------------------------

    def export_json(self) -> Dict[str, Any]:
        return {
            "title": self.title,
            "generated_utc": datetime.datetime.utcnow().isoformat(timespec="seconds")
            + "Z",
            "sections": self.sections,
            "primitives": self.primitives,
            "attack_chains": self.attack_chains,
        }

    # ----------------------------------------------------------------------
    # WRITE OUTPUT
    # ----------------------------------------------------------------------

    def write_markdown(self, filename: str = "nullpeas_report.md") -> Path:
        self.output_dir.mkdir(parents=True, exist_ok=True)
        path = self.output_dir / filename

        content_lines: List[str] = []
        content_lines.extend(self._render_header())
        content_lines.extend(self._render_sections())
        content_lines.extend(self._render_attack_chains())
        content_lines.extend(self._render_primitives())

        path.write_text("\n".join(content_lines), encoding="utf-8")
        return path

    def write_json(self, filename: str = "nullpeas_report.json") -> Path:
        self.output_dir.mkdir(parents=True, exist_ok=True)
        path = self.output_dir / filename
        path.write_text(json.dumps(self.export_json(), indent=2), encoding="utf-8")
        return path

    def write_all(self) -> Dict[str, Path]:
        """
        Convenience helper: write both Markdown and JSON.
        """
        md_path = self.write_markdown()
        json_path = self.write_json()
        return {"markdown": md_path, "json": json_path}

    # Backwards-compat for older brain.py that calls report.write()
    def write(self, filename: str = "nullpeas_report.md") -> Path:
        """
        Legacy shim: write only Markdown, matching older behaviour.
        """
        return self.write_markdown(filename)