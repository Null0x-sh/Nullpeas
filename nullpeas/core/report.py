from __future__ import annotations
from pathlib import Path
from typing import List, Dict, Any, Optional
import datetime
import json


class Report:
    """
    Nullpeas Unified Reporting Engine

    Responsibilities:
    - Accept traditional module sections (text reporting).
    - Accept structured offensive primitives.
    - Accept structured attack chains from chaining_engine.
    - Render clean Markdown for operators / defenders.
    - Export structured JSON for tooling / automation.

    Notes:
    - Backwards compatible with legacy add_section().
    - Does NOT execute exploits — still only reasoning + reporting.
    """

    def __init__(
        self,
        title: str = "Nullpeas Offensive Assessment Report",
        output_dir: str = "cache",
    ):
        self.title = title
        self.output_dir = Path(output_dir)

        # Human-readable document sections
        self.sections: List[Dict[str, Any]] = []

        # Structured intelligence for chaining + machine usage
        self.primitives: List[Dict[str, Any]] = []
        self.attack_chains: List[Dict[str, Any]] = []

    # ----------------------------------------------------------------------
    # Public API – TEXT REPORTING
    # ----------------------------------------------------------------------

    def add_section(self, heading: str, body_lines: List[str]):
        self.sections.append(
            {
                "heading": heading,
                "body_lines": body_lines or [],
            }
        )

    def add_finding(
        self,
        heading: str,
        summary: str,
        details: Optional[List[str]] = None,
    ):
        lines = [summary]
        if details:
            lines.append("")
            lines.extend(details)
        self.add_section(heading, lines)

    # ----------------------------------------------------------------------
    # Public API – OFFENSIVE PRIMITIVES
    # ----------------------------------------------------------------------

    def add_primitive(self, primitive: Any):
        """
        Accepts a Primitive dataclass OR dict.
        The chaining engine works off state, but the report
        also presents them for human consumption.
        """
        if hasattr(primitive, "__dict__"):
            primitive = primitive.__dict__
        self.primitives.append(primitive)

    def add_primitives(self, prims: List[Any]):
        for p in prims:
            self.add_primitive(p)

    # ----------------------------------------------------------------------
    # Public API – ATTACK CHAINS
    # ----------------------------------------------------------------------

    def add_attack_chain(self, chain: Dict[str, Any]):
        """
        Chain schema is generated by chaining_engine.
        Report just presents it clearly.
        """
        self.attack_chains.append(chain)

    def add_attack_chains(self, chains: List[Dict[str, Any]]):
        for c in chains:
            self.add_attack_chain(c)

    # ----------------------------------------------------------------------
    # MARKDOWN RENDERING
    # ----------------------------------------------------------------------

    def _render_header(self) -> List[str]:
        ts = datetime.datetime.utcnow().isoformat(timespec="seconds") + "Z"

        return [
            f"# {self.title}",
            "",
            f"_Generated: {ts}_",
            "",
            "---",
            "",
        ]

    def _render_sections(self) -> List[str]:
        lines: List[str] = []
        for section in self.sections:
            lines.append(f"## {section['heading']}")
            lines.append("")
            lines.extend(section["body_lines"])
            lines.append("")
        return lines

    def _render_attack_chains(self) -> List[str]:
        if not self.attack_chains:
            return []

        lines = []
        lines.append("## Offensive Attack Chains")
        lines.append("")
        lines.append(
            "Nullpeas does not execute exploits. "
            "This section models realistic escalation paths by combining discovered primitives."
        )
        lines.append("")

        for idx, chain in enumerate(self.attack_chains, start=1):
            lines.append(f"### Chain {idx}: {chain.get('title', 'Unnamed Chain')}")
            lines.append("")

            if desc := chain.get("description"):
                lines.append(desc)
                lines.append("")

            if primitives := chain.get("primitives", []):
                lines.append("**Primitives Utilised:**")
                for p in primitives:
                    lines.append(f"- `{p}`")
                lines.append("")

            if path := chain.get("chain_path", []):
                lines.append("**Chain Path:**")
                for step in path:
                    lines.append(f"- {step}")
                lines.append("")

            if impact := chain.get("impact"):
                lines.append("**Impact:**")
                lines.append(f"- {impact}")
                lines.append("")

            if guidance := chain.get("guidance", []):
                lines.append("**Operator Reasoning:**")
                for g in guidance:
                    lines.append(f"- {g}")
                lines.append("")

            lines.append("---")
            lines.append("")

        return lines

    def _render_primitives(self) -> List[str]:
        if not self.primitives:
            return []

        lines = []
        lines.append("## Offensive Primitives")
        lines.append("")
        lines.append(
            "These represent actionable privilege escalation or control opportunities. "
            "They are structured, chainable, and reasoned — but NOT executed."
        )
        lines.append("")

        for p in self.primitives:
            lines.append(f"### {p.get('id', 'primitive')}")
            lines.append("")

            lines.append(f"**Type:** `{p.get('type')}`")
            lines.append(f"**Surface:** `{p.get('surface')}`")
            lines.append(f"**Run As:** `{p.get('run_as')}`")
            lines.append(f"**Exploitability:** `{p.get('exploitability')}`")
            lines.append(f"**Stability:** `{p.get('stability')}`")
            lines.append(f"**Noise:** `{p.get('noise')}`")

            conf = p.get("confidence", {})
            lines.append(f"**Confidence:** {conf.get('score', '?')}/10")
            if conf.get("reason"):
                lines.append(f"- {conf['reason']}")

            val = p.get("offensive_value", {})
            if val:
                lines.append("")
                lines.append("**Offensive Value:**")
                lines.append(f"- Classification: {val.get('classification')}")
                lines.append(f"- Why: {val.get('why')}")

            ctx = p.get("context")
            if ctx:
                lines.append("")
                lines.append("**Context:**")
                for k, v in ctx.items():
                    lines.append(f"- {k}: {v}")

            lines.append("")
            lines.append("---")
            lines.append("")

        return lines

    # ----------------------------------------------------------------------
    # JSON EXPORT
    # ----------------------------------------------------------------------

    def export_json(self) -> Dict[str, Any]:
        return {
            "title": self.title,
            "generated_utc": datetime.datetime.utcnow().isoformat(timespec="seconds")
            + "Z",
            "sections": self.sections,
            "primitives": self.primitives,
            "attack_chains": self.attack_chains,
        }

    # ----------------------------------------------------------------------
    # WRITE OUTPUT
    # ----------------------------------------------------------------------

    def write_markdown(self, filename: str = "nullpeas_report.md") -> Path:
        self.output_dir.mkdir(parents=True, exist_ok=True)
        path = self.output_dir / filename

        content_lines = []
        content_lines.extend(self._render_header())
        content_lines.extend(self._render_sections())
        content_lines.extend(self._render_attack_chains())
        content_lines.extend(self._render_primitives())

        path.write_text("\n".join(content_lines), encoding="utf-8")
        return path

    def write_json(self, filename: str = "nullpeas_report.json") -> Path:
        self.output_dir.mkdir(parents=True, exist_ok=True)
        path = self.output_dir / filename
        path.write_text(json.dumps(self.export_json(), indent=2), encoding="utf-8")
        return path

    def write_all(self):
        self.write_markdown()
        self.write_json()